





![Screen Shot 2020-05-09 at 2.03.52 AM](/Users/ammar/Documents/Projects/YouTube-channel-Awj/مساق بايثون/التدوينات/Screen Shot 2020-05-09 at 2.03.52 AM.png)

## Try..Except

نستخدم هذه الطريقة عندما نعلم أن هناك جزء من الكود يمكن أن يسبب أخطاء عندما يتم تنفيذه. لذلك باستخدام هذه الطريقة نقول لبايثون: خذي هذا الجزء (الموجود داخل `try`) وحاولي تنفيذه؛ إذا سار الأمر بدون مشاكل وأخطاء فهذا  ما نريد، ولكن إذا حدث خطأ قومي بتنفيذ أوامر أخرى (موجودة داخل `except`). سنرى تفاصيل ذلك بعد قليل.

كمثال: افترض أن لدينا هذا البرنامج:

```python
v = 'Hello'
g = int(v)
print(g)
t = '98'
t = int(t)
print(t)
```

في السطر الأول أنشأنا متغيراً اسمه `v` ووضعنا فيه كلمة `"Hello"`. السطر الثاني يقوم بتحويل المتغير `v` إلى عدد صحيح (integer) لكن كما رأينا في درس سابق: لا يمكن تحويل أي سلسلة نصية إلى عدد، عندما نستخدم دالة `()int` مع سلسلة نصية فيجب أن تكون السلسلة النصية تحتوي على عدد فقط (مثل `"78"`). في هذه الحالة: عندما يصل تنفيذ البرنامج إلى السطر الثاني سيحدث خطأ ويتوقف تنفيذ البرنامج. 

لكن ماذا لو أردنا أن لا يتوقف تنفيذ البرنامج؟ نحن نعلم أن استخدام الدالة `()int` قد يسبب أخطاء عندما نستخدمها مع قيم غير مناسبة. قد تأتينا القيم من مصادر خارجية لا نتحكم نحن بها ولا نريد لبرنامجنا أن يفشل بسبب ذلك. إذن الحل هو باستخدام `try.. except`. سنضع السطر الثاني من البرنامج داخل `try` وفي حال حدوث خطأ سنضع الأوامر التي يجب تنفيذها داخل `except` كما يلي:

```python
v = 'Hello'
try:
	g = int(v)
except:
    print('لا يمكن تحويل القيمة المعطاة إلى عدد')
    g = 0
print(g)
t = '98'
t = int(t)
print(t)
```

الآن ستحاول بايثون تنفيذ الأمر الموجود داخل `try` ونحن نعلم في هذا المثال أن هذا الأمر سيسبب خطأ، فعندما يحدث الخطأ وبدلاً من أن يتوقف سير البرنامج ستنتقل بايثون إلى `except` وتنفذ الأوامر الموجودة فيها. في هذا المثال: ستطبع أنه لا يمكن تحويل القيمة المعطاة إلى عدد وستنشئ متغيراً يحمل نفس الاسم (`g`) وتضع بداخله الرقم `0` ثم ستخرج من `except`. الآن بعد `except` ستكمل تنفيذ البرنامج بشكل اعتيادي.

لاحظ أن هناك استخدام آخر لدالة `()int` في البرنامج لتحويل السلسلة النصية في المتغير `t` إلى عدد. لنضع ذلك في `try.. except` كما فعلنا قبل قليل:

```python
v = 'Hello'
try:
	g = int(v)
except:
    print('لا يمكن تحويل القيمة المعطاة إلى عدد')
    g = 0
print(g)
t = '98'
try:
	t = int(t)
except:
    t = -1
print(t)
```

في مثالنا هذا: السطر الذي يتم فيه تحويل `t` إلى عدد سيتم تنفيذه بدون أخطاء لأن السلسة النصية المخزنة في `t` تحتوي على عدد، لذلك فإن تحويل هذه السلسلة إلى عدد صحيح باستخدام `()int` سيمر بدون أخطاء، ولذلك فلن يتم الدخول إلى `except` وسينتقل البرنامج إلى تنفيذ الجملة الأخيرة وهي طباعة قيمة المتغير `t`.

لجعل هذا المثال أكثر واقعية سنقوم بتعديله ليصبح كما يلي:

```python
v = input('أدخل عدداً')
try:
	g = int(v)
except:
    print('لا يمكن تحويل القيمة المعطاة إلى عدد')
    g = 0
print(g)
t = input('أدخل عدداً')
try:
	t = int(t)
except:
    t = -1
print(t)
```

الآن جعلنا البرنامج يأخذ قيم المتغيرين `v` و `t` من المستخدم. المستخدم قد يدخل قيماً غير مناسبة للدالة `()int` ولكن بما أننا وضعنا الأوامر التي يمكن أن تسبب أخطاء داخل `try` فسيتم تنفيذ برنامجنا حتى آخر سطر بدون أن يحدث خطأ يؤدي إلى توقف البرنامج.

لاحظ أن طريقة `try.. except` تشبه كيفية عمل `if` و `else` كما رأينا سابقاً.

هناك أوقات يصبح فيها استخدام `try.. except` مهماً. مثلاً إذا كان برنامجك يعمل بشكل دائم لتلقي طلبات وتقديم خدمات، ففي هذه الحالة لا تريد أن يتوقف البرنامج أبداً، وهنا تبرز أهمية طريقة `try.. except`.