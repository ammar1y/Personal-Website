



## الطرق المتعددة

ذكرنا أنه باستخدام `else` يمكننا تشكيل ما يشبه مفترق طرق: إما أن تذهب في طريق `if`  أو في طريق `else` ، فهناك طريقان يتم اختيار أحدهما. لكن في الحقيقة: يمكننا تشكيل مفترق طرق لأكثر من طريقين؛ يمكننا تشكيل مفترق طرق لثلاث وأربع وخمس طرق وأكثر من ذلك. يمكننا فعل ذلك باستخدام `elif`.

مثال:

```python
if x < 2:
    print('صغير')
elif x < 10:
    print('وسط')
else:
    print('كبير')
print('انتهى البرنامج')
```

ويمكن تمثيل سير هذا الكود عن طريق المخطط التالي:

![]()

بداية سيسأل هل `x` أقل من 2؟ إذا كان الجواب "صحيح" سيطبع `صغير` وينتقل إلى جملة الطباعة الأخيرة ويطبع `انتهى البرنامج`. أما إذا كان الجواب "خطأ" وكانت `x` أكبر أو تساوي 2: عندها سينتقل إلى `elif` وسيسأل هل `x` أقل من 10؟ إذا كان الجواب "صحيح" سيطبع `وسط` وينتقل إلى جملة الطباعة الأخيرة ويطبع `انتهى البرنامج`. أما إذا كان الجواب "خطأ" وكانت `x` أكبر أو تساوي 10: عندها سينتقل إلى `else` وسيطبع `كبير` ثم سيطبع `انتهى البرنامج`. 

لاحظ أنه عندما يكون لدينا عدة شروط (مع `if` و `elif` و `else`) فدائماً سيتم تنفيذ الأوامر التابعة لواحد منها. مثلاً في المثال أعلاه: سيتم تنفيذ الأوامر التابعة لـ `if` **أو** الأوامر التابعة لـ `elif` **أو** الأوامر التابعة لـ `else`. 

هذا الكود يعتمد تنفيذه على قيمة `x`. إذا افترضنا أن `x` كانت قيمتها 0 قبل هذا الكود فما الذي ستتم طباعته؟ بناء على المخطط والشرح أعلاه: فإن البرنامج سيطبع `صغير` ثم `انتهى البرنامج` لأن جواب شرط `if` سيكون "صحيح" (أو "True") عندما تكون `x` قيمتها 0.

ماذا لو كانت قيمة `x` تساوي 5؟ باتباع نفس المنطق: سنرى أنه سيتم طباعة `وسط` ثم `انتهى البرنامج` لأن جواب شرط `if` سيكون "خطأ" لكن جواب شرط `elif` سيكون "صحيح".

ماذا لو كانت قيمة `x` تساوي 20؟ عندها سيتم طباعة `كبير` ثم `انتهى البرنامج` لأن شرط `if` سيكون جوابه "خطأ" (20 ليست أقل من 2) وكذلك شرط `elif` سيكون جوابه "خطأ" (لأن 20 ليست أقل من 10)، فبعد ذلك لا يتبقى لدينا إلا `else` و `else` دائماً ليس لها شرط، فعندما تكون أجوبة الشروط التي قبل `else` كلها "خطأ" يقوم البرنامج بتنفيذ الأوامر التابعة لـ `else`. 

إذا  أردنا التعبير عن هذا البرنامج بلغتنا سنقول: 

> إذا كانت `x` أقل من 2: اطبع `صغير`
>
> **أما** إذا كانت `x` أقل من 10: اطبع `وسط`
>
> إذا لم تتحقق الشروط **السابقة**: اطبع `كبير`

يمكنك إضافة ما تشاء من جمل `elif`. في هذا المثال كان لدينا جملة `elif` واحدة لكن إن احتجت يمكن أن تضع ثلاثة وأربعة وأكثر حسب ما تحتاجه في برنامجك. يمكنك أيضاً أن تستغني عن `else` إذا لم تكن تحتاجها. في المثال التالي لن يتم طباعة شيء إلا `انتهى البرنامج`:

```python
x = 50

if x < 2:
    print('صغير')
elif x < 10:
    print('وسط')
print('انتهى البرنامج')
```

![Screen Shot 2020-05-09 at 2.03.52 AM](/Users/ammar/Documents/Projects/YouTube-channel-Awj/مساق بايثون/التدوينات/Screen Shot 2020-05-09 at 2.03.52 AM.png)

## Try..Except

نستخدم هذه الطريقة عندما نعلم أن هناك جزء من الكود يمكن أن يسبب أخطاء عندما يتم تنفيذه. لذلك باستخدام هذه الطريقة نقول لبايثون: خذي هذا الجزء (الموجود داخل `try`) وحاولي تنفيذه؛ إذا سار الأمر بدون مشاكل وأخطاء فهذا  ما نريد، ولكن إذا حدث خطأ قومي بتنفيذ أوامر أخرى (موجودة داخل `except`). سنرى تفاصيل ذلك بعد قليل.

كمثال: افترض أن لدينا هذا البرنامج:

```python
v = 'Hello'
g = int(v)
print(g)
t = '98'
t = int(t)
print(t)
```

في السطر الأول أنشأنا متغيراً اسمه `v` ووضعنا فيه كلمة `"Hello"`. السطر الثاني يقوم بتحويل المتغير `v` إلى عدد صحيح (integer) لكن كما رأينا في درس سابق: لا يمكن تحويل أي سلسلة نصية إلى عدد، عندما نستخدم دالة `()int` مع سلسلة نصية فيجب أن تكون السلسلة النصية تحتوي على عدد فقط (مثل `"78"`). في هذه الحالة: عندما يصل تنفيذ البرنامج إلى السطر الثاني سيحدث خطأ ويتوقف تنفيذ البرنامج. 

لكن ماذا لو أردنا أن لا يتوقف تنفيذ البرنامج؟ نحن نعلم أن استخدام الدالة `()int` قد يسبب أخطاء عندما نستخدمها مع قيم غير مناسبة. قد تأتينا القيم من مصادر خارجية لا نتحكم نحن بها ولا نريد لبرنامجنا أن يفشل بسبب ذلك. إذن الحل هو باستخدام `try.. except`. سنضع السطر الثاني من البرنامج داخل `try` وفي حال حدوث خطأ سنضع الأوامر التي يجب تنفيذها داخل `except` كما يلي:

```python
v = 'Hello'
try:
	g = int(v)
except:
    print('لا يمكن تحويل القيمة المعطاة إلى عدد')
    g = 0
print(g)
t = '98'
t = int(t)
print(t)
```

الآن ستحاول بايثون تنفيذ الأمر الموجود داخل `try` ونحن نعلم في هذا المثال أن هذا الأمر سيسبب خطأ، فعندما يحدث الخطأ وبدلاً من أن يتوقف سير البرنامج ستنتقل بايثون إلى `except` وتنفذ الأوامر الموجودة فيها. في هذا المثال: ستطبع أنه لا يمكن تحويل القيمة المعطاة إلى عدد وستنشئ متغيراً يحمل نفس الاسم (`g`) وتضع بداخله الرقم `0` ثم ستخرج من `except`. الآن بعد `except` ستكمل تنفيذ البرنامج بشكل اعتيادي.

لاحظ أن هناك استخدام آخر لدالة `()int` في البرنامج لتحويل السلسلة النصية في المتغير `t` إلى عدد. لنضع ذلك في `try.. except` كما فعلنا قبل قليل:

```python
v = 'Hello'
try:
	g = int(v)
except:
    print('لا يمكن تحويل القيمة المعطاة إلى عدد')
    g = 0
print(g)
t = '98'
try:
	t = int(t)
except:
    t = -1
print(t)
```

في مثالنا هذا: السطر الذي يتم فيه تحويل `t` إلى عدد سيتم تنفيذه بدون أخطاء لأن السلسة النصية المخزنة في `t` تحتوي على عدد، لذلك فإن تحويل هذه السلسلة إلى عدد صحيح باستخدام `()int` سيمر بدون أخطاء، ولذلك فلن يتم الدخول إلى `except` وسينتقل البرنامج إلى تنفيذ الجملة الأخيرة وهي طباعة قيمة المتغير `t`.

لجعل هذا المثال أكثر واقعية سنقوم بتعديله ليصبح كما يلي:

```python
v = input('أدخل عدداً')
try:
	g = int(v)
except:
    print('لا يمكن تحويل القيمة المعطاة إلى عدد')
    g = 0
print(g)
t = input('أدخل عدداً')
try:
	t = int(t)
except:
    t = -1
print(t)
```

الآن جعلنا البرنامج يأخذ قيم المتغيرين `v` و `t` من المستخدم. المستخدم قد يدخل قيماً غير مناسبة للدالة `()int` ولكن بما أننا وضعنا الأوامر التي يمكن أن تسبب أخطاء داخل `try` فسيتم تنفيذ برنامجنا حتى آخر سطر بدون أن يحدث خطأ يؤدي إلى توقف البرنامج.

لاحظ أن طريقة `try.. except` تشبه كيفية عمل `if` و `else` كما رأينا سابقاً.

هناك أوقات يصبح فيها استخدام `try.. except` مهماً. مثلاً إذا كان برنامجك يعمل بشكل دائم لتلقي طلبات وتقديم خدمات، ففي هذه الحالة لا تريد أن يتوقف البرنامج أبداً، وهنا تبرز أهمية طريقة `try.. except`.