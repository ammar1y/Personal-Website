في هذا الدرس سنبدأ الحديث عن الحلقات التكرارية. باستخدام الحلقات نجعل الكومبيوتر يقوم بمهام تكرارية، يكرر تنفيذ أوامر لعدد كبير من المرات. نحن لا نحب أن نقوم بمهام كهذه. حتى وإن أردنا القيام بها ستتطلب منا وقتاً طويلاً. لكن باستخدام الكومبيوتر نحصل على النتائج بلمح البصر.

هناك نوعان من الحلقات التكرارية في بايثون: حلقات `while` وحلقات `for`. سنبدأ بالحديث عن حلقات `while`.

تكلمنا بشكل مبسط عن الحلقات عندما شرحنا النمط التكراري في درس سابق. لنعد الآن إلى المثال الذي رأيناه في ذلك الدرس:

```python
n = 5
while n > 0:
  print(n)
  n = n - 1
print('Finished')
```

في السطر الأول ننشئ متغيراً اسمه `n` ونضع فيه الرقم 5. ثم نأتي لنجد كلمة `while` والتي تعني أننا سندخل حلقة تكرارية. دائماً مع كل `while` ومع كل حلقة تكرارية هناك شرط، مثل شرط `if`. إذا تحقق الشرط ندخل الحلقة وننفذ التعليمات التي بداخلها وإن لم يتحقق نتجاوز الحلقة ونتجاهل التعليمات التي بداخلها. 

فوصلنا إلى `while`. الشرط هنا هو: `n > 0` يعني هنا نطرح سؤالاً: هل `n` أكبر من 0؟ إذا كان الجواب `True` ندخل الحلقة وإن كان `False` نتجاوز الحلقة. بما أن قيمة `n` هي 5، و 5 أكبر من 0، إذن تحقق الشرط وسندخل الحلقة. 

دخلنا الحلقة. أول تعليمة تصادفنا داخل الحلقة هي:

```python
print(n)
```

والتي ستطبع قيمة `n` على الشاشة. بعدها نأتي للتعليمة الثانية داخل الحلقة:

```python
n = n - 1
```

هذه التعليمة ستطرح 1 من قيمة `n`.  فـ `n` كانت 5، ستصبح الآن 4. الآن أين سنذهب؟ سنعود إلى بداية الحلقة، وبالتحديد إلى شرط الحلقة، وسنسأل مرة أخرى: هل `n` أكبر من 0؟ الآن `n` تساوي 4، و 4 أكبر من 0، إذن جواب الشرط `True` وسيتم تنفيذ تعليمات الحلقة مرة أخرى. سيتم طباعة قيمة `n` ثم طرح 1 من قيمة `n`. ستصبح قيمة `n` عندها تساوي 3. 

نعود بعدها إلى شرط الحلقة. نسأل: هل `n` أكبر من 0؟ وبما أن `n` تساوي الآن 3 فسيكون جواب الشرط `True` وسيتم تنفيذ تعليمات الحلقة مرة أخرى. سيتم طباعة قيمة `n` ثم طرح 1 من قيمة `n`. ستصبح قيمة `n` عندها تساوي 2. 

نعود بعدها مرة أخرى إلى شرط الحلقة. نسأل: هل `n` أكبر من 0؟ وبما أن `n` تساوي الآن 2 فسيكون جواب الشرط `True` وسيتم تنفيذ تعليمات الحلقة مرة أخرى. سيتم طباعة قيمة `n` ثم طرح 1 من قيمة `n`. ستصبح قيمة `n` عندها تساوي 1. 

نعود بعدها مرة أخرى إلى شرط الحلقة. نسأل: هل `n` أكبر من 0؟ وبما أن `n` تساوي الآن 1 فسيكون جواب الشرط `True` وسيتم تنفيذ تعليمات الحلقة مرة أخرى. سيتم طباعة قيمة `n` ثم طرح 1 من قيمة `n`. ستصبح قيمة `n` عندها تساوي 0. 

الآن نعود مرة أخرى إلى شرط الحلقة ونسأل: هل `n` أكبر من 0؟ الآن `n` تساوي 0، و 0 يساوي 0، لكن 0 ليس أكبر من 0. إذن هذه المرة سيكون جواب الشرط `False` وهذا يعني أننا انتهينا من أمر حلقة `while` هذه وسننتقل إلى ما بعدها. ماذا يأتي بعدها؟ تأتي تعليمة الطباعة والتي ستطبع "Finished" على الشاشة.

المخطط التالي يوضح كيفية سير البرنامج:

![]()

المتغير `n` في هذا المثال يمكن أن نسميه متغير الحلقة، يعني هو المتغير الذي يعتمد شرط الحلقة عليه. ماذا لو كان البرنامج بهذا الشكل؟

 ```python
n = 5
while n > 0:
  print(n)
print('Finished')
 ```

ما الذي سيحدث عند تنفيذ هذا البرنامج؟

في هذا البرنامج: الحلقة لا تحتوي على تعليمة إنقاص قيمة `n`. هذا سيؤدي إلى أن نكرر الحلقة لعدد لا نهائي من المرات، يعني أنه سيتم تكرار تنفيذ تعليمات الحلقة بلا نهاية، وذلك بسبب أن شرط الحلقة سيتحقق دائماً: قيمة `n` ستبقى 5، و 5 أكبر من 0، لا يوجد تعليمة لإنقاص قيمة `n`. إذن ستستمر بايثون بطباعة قيمة `n` وهي 5 بلا نهاية. هذا النوع من الحلقات يسمى الحلقات اللانهائية.

المثال التالي يعرض حلقة لانهائية من نوع آخر:

```python
while True:
  print('مرحباً')
```

هذه البرنامج سيقوم بتكرار طباعة كلمة "مرحباً" بلا نهاية. لاحظ هنا أن شرط الحلقة هو `True`، لا يوجد سؤال هنا. يعني هنا اختصرنا قصة السؤال ووضعنا الجواب مباشرة وهو `True` وهذه ال `True` لا تتغير لأنها قيمة ثابتة وليست متغيراً. فهذه الحلقة ستستمر بالتكرار إلى ما لا نهاية.

## تعليمة كسر الحلقة: break

هناك كلمة في بايثون يمكن أن نضعها داخل الحلقات. عندما يصل البرنامج إلى هذه الكلمة يتم الخروج مباشرة من الحلقة. هذه الكلمة هي `break`. لننظر إلى المثال التالي:

```python
while True:
  line = input()
  if line == 'قف':
    break
  print(line)
print('انتهى')
```

عندما ننظز إلى هذا المثال نرى حلقة تبدو لانهائية لأن شرط الحلقة هو `True` كما رأينا قبل قليل. ماذا يفعل هذا البرنامج؟ عندما يدخل البرنامج في حلقة `while` والتي نفترض أن تنفيذها سيستمر بلا توقف لأن شرطها `True`، عندما يدخل البرنامج هذه الحلقة يقرأ إدخالاً من المستخدم باستخدام الدالة `input` ويقوم بتخزين ما يقرؤه من المستخدم في متغير اسمه `line`. ثم يفحص ما أدخله المستخدم باستخدام `if`: إذا أدخل المستخدم كلمة "قف" سيواجه البرنامج كلمة `break` ويخرج من الحلقة مباشرة. أما إذا أدخل المستخدم أي شيء آخر سيطبع ما أدخله المستخدم ثم سيكرر تعليمات الحلقة ويقرأ منه إدخالاً آخراً ويستمر في تكرار الحلقة حتى يدخل المستخدم كلمة "قف". 

إذن `break` يمكن أن تستعمل مع الحلقات لتكرير تنفيذ مجموعة من التعليمات حتى يتحقق الشرط الذي نريده. هذا يمكن أن يكون له تطبيقات مفيدة في برامجك لاحقاً.

## تعليمة continue

هناك تعليمة أخرى تستعمل مع الحلقات وهي تعليمة `continue`. ماذا تفعل هذه التعليمة؟ هذه التعليمة تتخطى التكرار الحالي وتنتقل للتكرار التالي في الحلقة. سنرى مثالاً لتوضيحها.

```python
while True:
  line = input()
  if line[0] == '#':
    continue
  if line == 'قف':
    break
  print(line)
print('انتهى')
```

هذا المثال مشابه للمثال الذي رأيناه عندما تكلمنا عن `break`. الزيادة في هذا المثال هي:

```python
if line[0] == '#':
    continue
```

كما في مثال `break`: في هذا المثال يستمر البرنامج بقراءة إدخال من المستخدم ويطبع هذا الإدخال حتى يدخل المستخدم كلمة "قف". عندها يخرج البرنامج من الحلقة ويطبع "انتهى". لكن الزيادة هنا أنه إذا أدخل المستخدم شيئاً يبدأ بهذا الرمز: "#" فإن البرنامج يتجاوز بقية التعليمات داخل الحلقة ويعود إلى بداية الحلقة مرة أخرى، يعني عندما يرى البرنامج كلمة `continue` يقفز مباشرة إلى بداية الحلقة، إلى شرط الحلقة.

لاحظ أننا استخدمنا `line[0]` للوصول إلى أول حرف من النص الذي أدخله المستخدم. سنتعلم لاحقاً المزيد عن هذا الأمر.

إذن `break` تخرج من الحلقة إلى التعليمة التي بعد الحلقة. `continue` تخرج لتعود إلى بداية الحلقة (شرط الحلقة).

## حلقة for

تعرفنا سابقاً على حلقة `while` ورأينا أنها تتكرر طالما بقي شرطها متحققاً. الآن سنتعرف على حلقة `for` وهي نوع آخر من الحلقات تتكرر لعدد محدد (معروف مسبقاً) من المرات.

لنر المثال التالي عن حلقة `for`:

```python
for i in [1,2,4,5,7]:
  print(i)
print('انتهى')
```

في هذه الحلقة سيتم تكرار تعليمات الحلقة لكل عنصر في هذه القائمة: `[1,2,4,5,7]`. هذا يعني أن أمر الطباعة هذا:

```python
print(i)
```

سيتم تنفيذه مرة لكل عنصر في تلك القائمة، وفي كل مرة ستكون قيمة `i` نفس قيمة ذلك العنصر. يعني أنه في المرة الأولى لتكرار الحلقة سيتم طباعة "1" وهو العنصر الأول في القائمة؛ في التكرار الثاني سيتم طباعة "2" والذي هو العنصر الثاني في القائمة، وهكذا حتى نصل إلى العنصر الأخير وهو "7" حيث ستتم طباعته ثم تنتهي الحلقة ويتم الخروج منها إلى الأمر الذي بعدها وهو أمر الطباعة الذي سيطبع كلمة "انتهى".

في هذا المثال اخترنا أن يكون اسم متغير الحلقة `i` لكن يمكن أن نختار أي اسم نريده. 

في المثال التالي سنمر على قائمة تحتوي على سلاسل نصية:

```python
for f in ['Ahmad', 'Leen', 'John']:
  print('Happy birthday ' + f)
```

هذا البرنامج سيمر على عناصر هذه القائمة وسيطبع لكل عنصر عبارة تهنئة. في البداية سيمر على "Ahmad" وبالتالي ستكون قيمة المتغير `f` تساوي "أحمد" وسينفذ الأوامر داخل الحلقة. هناك أمر واحد، أمر الطباعة، فسينفذه ويطبع:

```
Happy birthday Ahmad
```

ثم سيمر على بقية العناصر ويطبع جملاً مشابهة:

```
Happy birthday Leen
Happy birthday John
```

### تحليل حلقة `for`

لننظر إلى المثال التالي:

```python
for w in [1,3,4,7,3]:
  print(w)
```

عرفنا من دراستنا لحلقة `for` أن هذا البرنامج سيمر على عناصر القائمة ويطبعها على الشاشة. هذا البرنامج مكافئ للبرنامج التالي الذي سنكتبه بدون استخدام حلقة `for`:

```python
w = 1
print(w)
w = 3
print(w)
w = 4
print(w)
w = 7
print(w)
w = 3
print(w)
```

هذا يشابه ما تفعله حلقة `for`: تمر على كل عنصر، وتجعل متغير الحلقة يحمل قيمة ذلك العنصر، ثم تنفذ التعليمات داخل الحلقة.

ملاحظة: `break` و `continue` تعمل مع حلقة `for` مثلما تعمل مع حلقة `while`.

ملاحظة: رأينا في هذا الدرس شيئاً جديداً هو القوائم. سنتعرف عليها بالتفصيل في المستقبل.

## مثال: إيجاد أكبر عدد في قائمة من الأعداد

الآن سنرى برنامجاً يقوم بالبحث في قائمة من الأعداد لإيجاد أكبر عدد فيها. إذا كانت القائمة تحتوي على 10 عناصر، يمكنك بسهولة أن تنظر إليها وتجد أكبر رقم لكن ماذا لو كانت القائمة تحتوي على 1,000,000 عنصر؟ ستحتاج وقتاً طويلاً جداً لإيجاد أكبر رقم في هذه الحالة. لكن باستخدام بايثون يمكن إيجاد أكبر عدد خلال أقل من ثانية.

في المثال التالي يقوم البرنامج بالبحث عن أكبر عدد في قائمة تتكون من 5 أعداد موجبة. نفس البرنامج يمكن أن يستخدم مع قائمة فيها ألف عدد أو مليون عدد.

```python
largest = -1

for n in [2,6,912,77,13]:
  if n > largest:
    largest = n
    
print('Largest number is:', largest)
```

في السطر الأول نقوم بإنشاء متغير اسمه `largest` ونضع فيه عدداً سالباً وهو -1 (انتبه إلى إشارة السالب والتي تعني أن هذا العدد أقل من الصفر). هذا العدد نعرف أنه أقل من أي عدد موجود في القائمة التي نريد البحث فيها لأنها تحتوي على أعداد موجبة فقط كما قلنا.

بعد ذلك نأتي إلى حلقة `for`. سنمر في الحلقة على قائمة فيها 5 أعداد. سنأخذ كل عدد ونقارنه بالعدد المخزن في `largest`. إذا كان العدد أكبر من العدد المخزن في `largest` سيتم وضع هذا العدد في `largest` بدلاً من العدد المخزن مسبقاً. لتوضيح هذا دعونا نتتبع سير الحلقة.

في التكرار الأول للحلقة ستكون قيمة متغير الحلقة `n` تساوي 2 وهي قيمة العنصر الأول في القائمة. ثم سنبدأ بتنفيذ تعليمات الحلقة: لدينا في البداية شرط `if`. سنقارن `n` مع `largest`، نسأل: هل `n` أكبر من `largest`؟. في `n` لدينا 2 وفي `largest` لدينا -1. بالتأكيد 2 أكبر من -1، إذن جواب السؤال (جواب شرط `if`) سيكون `True` وسيتم تنفيذ التعليمة التابعة لـ `if` وبالتالي سيتم تخزين قيمة `n` داخل `largest`. إذن `largest` كان فيها -1 والآن أصبح فيها 2.

في التكرار الثاني للحلقة ستكون قيمة `n` تساوي 6 وسنعيد نفس الخطوات. سنبدأ بتنفيذ تعليمات الحلقة: سنقارن `n` مع `largest`، نسأل: هل `n` أكبر من `largest`؟. في `n` لدينا الآن 6 وفي `largest` لدينا 2. و 6 أكبر من 2، إذن جواب شرط `if` سيكون `True` وسيتم تنفيذ التعليمة التابعة لـ `if` وبالتالي سيتم تخزين قيمة `n` داخل `largest`. إذن `largest` كان فيها 2 والآن أصبح فيها 6.

في التكرار الثالث سنتبع نفس الخطوات. ستكون قيمة `n` في هذا التكرار 912. عندما نسأل هل `n` أكبر `largest` والذي قيمته الآن 6؟ سيكون الجواب `True` بالتأكيد وسيتم وضع 912 داخل `largest`.

في التكرار الرابع ستكون قيمة `n` تساوي 77. عندما نسأل في هذا التكرار هل `n` أكبر `largest` والذي قيمته الآن 912؟ سيكون الجواب `False` لأن 77 ليست أكبر من 912. إذن لن يتم تنفيذ التعليمة التابعة لـ  `if` في هذا التكرار وستبقى قيمة `largest` على ما هي عليه (912).

في التكرار الخامس والأخير ستكون قيمة `n` تساوي 13. عندما نسأل في هذا التكرار هل `n` أكبر `largest` والذي قيمته ما زالت 912؟ سيكون الجواب `False` لأن 13 ليست أكبر من 912. إذن لن يتم تنفيذ التعليمة التابعة لـ  `if` في هذا التكرار وستبقى قيمة `largest` على ما هي عليه (912).

الآن نكون قد انتهينا من حلقة `for` لأننا كررنا تنفيذ تعليمات الحلقة لكل عناصر القائمة. بعد حلقة `if` نجد أمر طباعة سيطبع التالي:

```
Largest number is 912
```

أي: "أكبر عدد هو 912"، لأن القيمة المخزنة في `largest` عند نهاية الحلقة كانت 912.

## مثال: جمع الأعداد الموجودة في قائمة

تخيل أن لديك قائمة فيها مليون عدد وتريد جمع هذه الأعداد. البرنامج التالي يقوم بذلك.

```python
import random
numbers = []
for i in range(1000000):
  random.seed(i)
  numbers.append(random.randint(1,300))
  
total = 0
for num in numbers:
  total = total + num
 
print('Total =', total)
```

الآن تجاهل الأسطر الأربعة الأولى في البرنامج. هذه الأسطر تقوم بتخزين مليون عدد في قائمة اسمها `numbers`. ستتعلم لاحقاً كيف تعمل هذه الأسطر الأربعة. نحن يهمنا في هذا البرنامج الأسطر التي بعدها والتي تجمع الأعداد الموجودة في `numbers`.

نبدأ بتعريف متغير اسمه `total` ونضع فيه 0. هذا المتغير سنخزن فيه مجموع الأعداد الموجودة في القائمة `numbers`. هذه القائمة تحتوي على مليون عدد. بعد ذلك تبدأ حلقة `for`. سنقوم بالمرور على المليون عنصر. في كل تكرار للحلقة سنمر على عنصر من العناصر، يعني الحلقة ستتكرر مليون مرة. في كل تكرار سنضيف قيمة العنصر إلى `total`.

لنفترض أن الأعداد الثلاثة الأولى في القائمة `numbers` هي 4 و 77 و 90.

في التكرار الأول ستكون قيمة متغير الحلقة `num` تساوي قيمة العنصر الأول في القائمة وهو 4. سيتم تنفيذ التعليمة الموجودة داخل الحلقة وهي إضافة قيمة `num` إلى `total`. في `total` لدينا الآن 0 وفي `num` لدينا 4. بعد تنفيذ التعليمة ستصبح قيمة `total` تساوي 0 + 4 أي 4.

في التكرار الثاني ستكون قيمة متغير الحلقة `num` تساوي قيمة العنصر الثاني في القائمة `numbers` وهو 77. سيتم تنفيذ التعليمة الموجودة داخل الحلقة وهي إضافة قيمة `num` إلى `total`. في `total` لدينا الآن 4 وفي `num` لدينا 77. بعد تنفيذ التعليمة ستصبح قيمة `total` تساوي 4 + 77 أي 81 وهو مجموع أول عنصرين في القائمة.

في التكرار الثالث سيتم إعادة نفس الخطوات وستصبح قيمة `total` في نهاية التكرار الثالث تساوي 81 + 90 أي 171 وهو مجموع أول ثلاثة عناصر في القائمة.

وسيتم تكرار الحلقة لبقية العناصر في القائمة `numbers` حتى نمر على جميع العناصر (مليون عنصر). بعد التكرار الأخير ستكون قيمة `total` تساوي مجموع المليون عدد الموجودة في القائمة `numbers`.

بعد حلقة `for` هناك تعليمة طباعة ستطبع مجموع الأعداد المخزن في `total`.

## مثال: البحث في قائمة عن قيمة معينة

لنفترض أن لديك قائمة فيها 100,000 عنصر. هذه العناصر هي أرقام الأطباء في مدينتك. والآن وجدت رقماً جديداً (0056284364) وتريد أن تعرف هل هو موجود في القائمة أم لا. بالطبع لن تبحث بنفسك لأن هذا صعب ويستغرق وقتاً طويلاً. لكن بما أنك تعرف الآن كيف تستخدم الحلقات في بايثون يمكنك كتابة برنامج بسيط يؤدي المهمة مثل التالي: 

```python
import random
import string
phone_numbers = []
for i in range(100000):
  random.seed(i)
  phone_numbers.append(
    ''.join(random.choices(string.digits, k=10)))

found = False
for v in phone_numbers:
  if v == '0056284364':
    found = True

print(found)
```

تجاهل الأسطر السبعة الأولى فهي تقوم بإنشاء قائمة وتخزين 100,000 رقم فيها، وفي هذه الأسطر أشياء لم نتعلمها بعد، فتجاهلها الآن. المهم أن بعد هذه الأسطر سيكون لدينا قائمة في متغير اسمه `phone_numbers` (يعني "أرقام الهواتف" بالعربية). في هذه القائمة 100,000 رقم هاتف.

نبدأ مع السطر التالي:

```python
found = False
```

هذا السطر فيه شيء جديد بالنسبة لنا. نعرف أننا نقوم بإنشاء متغير اسمه `found` (معنى found بالعربية "تم إيجاده") ولكننا هنا لا نضع فيه رقماً ولا سلسلة نصية، بل نضع فيه `False`. هل يمكن ذلك؟ نعم يمكن ذلك. هذا المتغير يسمى متغيراً منطقياً (boolean variable). هذا النوع من المتغيرات يمكن أن يحتوي على واحدة من قيمتين: إما `True` وإما `False`. ففي هذا السطر نضع قيمة `False` في هذا المتغير. سنرى بعد قليل ما معنى ذلك.

في السطر التالي نجد حلقة `for`. في هذه الحلقة نبحث في قائمة أرقام الهواتف عن الرقم الجديد الذي وجدناه. نفعل ذلك كالتالي: نمر على كل عنصر ونفحص العنصر: هل يساوي الرقم الذي نبحث عنه؟ إذا كان يساويه نضع `True` في المتغير `found` مما يعني أننا وجدنا العنصر. لكن إذا مررنا على كل العناصر ولم يكن أي عنصر يساوي الرقم الذي نبحث عنه ستبقى قيمة المتغير `found` كما هي (ستبقى `False`) مما يعني أن العنصر لم يتم إيجاده.

بعد الحلقة نطبع قيمة `found`. إن تم إيجاد العنصر سيتم طباعة "True" على الشاشة وإن لم يتم إيجاده سيتم طباعة "False".

 ## مثال: إيجاد أصغر عدد في قائمة

رأينا سابقاً كيف يمكننا إيجاد أكبر عدد في قائمة من الأعداد الموجبة:

```python
largest = -1

for n in [2,6,912,77,13]:
  if n > largest:
    largest = n
    
print('Largest number is:', largest)
```

الآن إذا أردنا إيجاد أصغر عدد في قائمة من الأعداد: كيف يمكننا فعل ذلك؟ هل يكفي تغيير إشارة < إلى >؟ بالطبع لا. في المثال أعلاه وضعنا عدداً سالباً (-1) في المتغير `largest` قبل بداية الحلقة لأننا نعرف أننا نبحث في قائمة من الأعداد الموجبة مما يجعل -1 أقل من أي عدد يمكن أن يكون في هذه القائمة. لكن الآن ما هي القيمة التي يجب استخدامها قبل الدخول في الحلقة؟ إذا استخدمنا -1 فالبرنامج لن يعمل بشكل صحيح لأن -1 قد تكون أصغر من كل الأعداد الموجودة في القائمة وبالتالي لن يتم إيجاد أصغر عدد في القائمة بشكل صحيح. ماذا لو استخدمنا 1000 مثلاً؟ أيضاً في هذه الحالة لن يعمل البرنامج بشكل صحيح عندما تكون هناك قيم الأعداد في القائمة كلها أكبر من 1000. إذن ماذا نفعل؟

يمكننا استخدام `None`. ذكرنا `None` سريعاً في السابق وقلنا أنها كلمة محجوزة في بايثون وتعني "لا شيء" وتستخدم للدلالة على عدم وجود شيء. سنستخدمها كما يلي:

```python
smallest = None

for n in [1,4,0,23,2000]:
  if smallest == None:
    smallest = n
  elif n < smallest:
    smallest = n
    
print('Smallest number is', smallest)
```

في السطر الأول وضعنا `None` في متغير اسمه `smallest` (معنى smallest بالعربية: الأصغر). ثم نأتي إلى حلقة `for`. سنمر على الأعداد في القائمة المعطاة بحثاً عن أصغر عدد. 

في التكرار الأول للحلقة ستكون قيمة متغير الحلقة `n` تساوي 1. سيتم تنفيذ التعليمات داخل الحلقة: في البداية لدينا جملة شرطية تسأل: هل قيمة المتغير `smallest` هي `None`؟ إذا كان جواب هذا السؤال `True` سيتم وضع قيمة `n` داخل `smallest` أما إذا كان الجواب `False` سيتم الانتقال إلى جملة `elif` والتي ستسأل: هل `n` أقل من `smallest`؟ هذا الجزء شبيه بمثال البحث عن أكبر عدد في الأعلى. إذا كان جواب هذا الشرط `True` سيتم وضع قيمة `n` داخل `smallest`. ففي التكرار الأول ستكون قيمة `smallest` هي `None` وبالتالي فإن شرط `if` سيتحقق وسيتم وضع قيمة `n` وهي 1 داخل `smallest` والانتقال للتكرار الثاني. 

في التكرار الثاني ستكون قيمة `n` تساوي 4 ولن يتحقق شرط `if` لأن `smallest` الآن تساوي 1 وليست `None` وكذلك لن يتحقق شرط `elif` لأن `n` وتساوي 4 ليست أصغر من `smallest` والتي تساوي 1، وسيتم بعدها الانتقال إلى التكرار الثالث.

في التكرار الثالث ستكون قيمة `n` تساوي 0 ولن يتحقق شرط `if` لأن `smallest` تساوي 1 وليست `None` ولكن سيتحقق شرط `elif` لأن `n` وتساوي 0 أصغر من `smallest` والتي تساوي 1، لذلك سيتم وضع قيمة `n` وهي 0 داخل `smallest`. وسيتم بعدها الانتقال إلى التكرار الرابع.

في التكرار الرابع ستكون قيمة `n` تساوي 23 ولن يتحقق شرط `if` لأن `smallest` ليست `None` وكذلك لن يتحقق شرط `elif` لأن `n` وتساوي 23 ليست أصغر من `smallest` والتي تساوي 0. وسيتم بعدها الانتقال إلى التكرار الخامس والأخير.

في التكرار الخامس ستكون قيمة `n` تساوي 2000 ولن يتحقق شرط `if` لأن `smallest` ليست `None` وكذلك لن يتحقق شرط `elif` لأن `n` وتساوي 2000 ليست أصغر من `smallest` والتي تساوي 0. الآن انتهت الحلقة. 

في النهاية يتم تنفيذ تعليمة الطباعة والتي ستطبع:

```
Smallest number is 0
```

وترجمة ذلك أن "أصغر عدد هو 0" وذلك لأن القيمة المخزنة في `smallest` عند نهاية الحلقة كانت 0.

إذن رأينا في هذا المثال كيف استخدمنا `None` لنتمكن من إيجاد أصغر عدد بشكل سليم. لاحظ أن هذا الجزء من الكود:

```python
if smallest == None:
    smallest = n
```

هو فقط وظيفته أن يضع أول عدد في القائمة داخل `smallest` في التكرار الأول للحلقة. لو حذفنا هذا الجزء سيحدث التالي: في التكرار الأول ستكون قيمة `smallest` هي `None` وعندما نصل لهذا الجزء (طبعاً سنستخدم `if` بدل `elif` لأننا حذفنا جملة `if`):

```python
elif n < smallest:
    smallest = n
```

سيحدث خطأ في تنفيذ البرنامج لأن قيمة `n` في هذا التكرار الأول ستكون 1 وقيمة `smallest` ستكون `None` كما قلنا، ولا يمكن مقارنة 1 مع `None`. يمكنك مقارنة عدد مع عدد أما مقارنة عدد مع `None` فلا معنى لها وستحدث خطأ في تنفيذ البرنامج. لهذا السبب استخدمنا هذا الكود:

```python
if smallest == None:
    smallest = n
```

ليتعامل مع الوضع في التكرار الأول.